# 1. 인터넷 네트워크

인터넷 통신은 어떻게 가능한것일까?  
어떻게 목적지까지 정확하게 도달할 수 있을까?

### 1.1. IP
클라이언트와 서버는 각각 IP 주소를 가진다.  
패킷에 클라이언트와 서버의 IP가 있어 서로 목적지까지 도달할 수 있다.

하지만 IP의 한계가 있다.
- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송된다.
- 비신뢰성 : 패킷중간에 사라지거나 패킷이 순서대로 오지 않을 수 있다.
- 프로그램 구분 : 게임하면서 음악을 듣는것처럼 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이라면 구분할 수 없다.

```
L3인 Network Layer에서는 MTU(Maximum Transmission Unit)를 설정한다.
일반적으로 이더넷이 L3 에서 주로 사용되기에, 이더넷 기준으로는 MTU는 1500 바이트이다.
여기서 IP헤더와 TCP헤더 각 20바이트를 제외하면 1460 byte 이다.
그래서 MSS(Maximum Segment Size)는 1460 byte 이다.
```
![networkLayer.png](img/networkLayer.png)


### 1.2. TCP/UDP
TCP(Transmission Control Protocol) : 전송 제어 프로토콜로 말 그대로 전송을 제어한다.
- 연결 지향 (3way handshake)
- 데이터 전달 보장
- 순서 보장
- 신뢰성
- 현재는 대부분 TCP 사용

3 way handshake & 4 way handshake  
![handshake.png](img/handshake.png)

UDP(User Datagram Protocol)
- 기능이 거의 없음
- 연결 지향도 아님
- 데이터 전달 보장도 아님
- 순서도 보장하지 않음
- 하지만 단순하고 빠름
- 정리하면 IP와 거의 같고 port와 체크섬 정도만 추가됨
- 애플리케이션에서 추가 작업이 필요함

### PORT
IP는 목적지 서버를 찾는것  
PORT는 서버 안에서 돌아가는 애플리케이션을 찾는것
- 0 ~ 65535 까지 할당 가능
- 0 ~ 1023 까지는 잘 알려진 포트로 사용하지 않는것이 좋다.
  - FTP : 20, 21
  - TELNET : 23
  - HTTP : 80
  - HTTPS : 443

### DNS(Domain Name System)
도메인 명과 IP 주소를 매핑해준다.

---
# 2. URI와 웹 브라우저 요청 흐름
### 2.1. URI
- URI(Uniform Resource Identifier) : URL + URL  
- URL(Uniform Resource Locator) : 리소스가 있는 위치를 지정   
- URN(Uniform Resource Identifier) : 리소스에 이름을 부여  
![uri.png](img/uri.png)

URI 구성 요소  
https://www.google.com:443/search?q=hello&hl=ko 를 예로 들면  
- scheme : https
- host : www.google.com
- port : 443
- path : /search
- query : ?q=hello&hl=ko
- fragment : html 내부 북마크 등에 사용되고 서버에 전송하는 정보는 아니다. 

### 2.2. 웹 브라우저 요청 흐름
- HTTP 메시지를 TCP/IP 패킷으로 감싸고 보낸다.
- 서버에서 패킷을 까고 요청을 다시 전달한다.
- 클라이언트에서 패킷을 까고 확인한다.

---
# 3. HTTP 기본
### 3.1. 모든 것이 HTTP
- 거의 모든 형태의 데이터를 전송 가능하다.
- 현재는 HTTP/1.1 을 주로 사용한다.

특징
- 클라이언트 서버 구조
- stateless
- connectionless
- http message
- 단순함, 확장 가능

### 3.2. 클라이언트 서버 구조
- request, response 구조이다.
- 클라이언트는 서버에 요청을 보내고 응답을 대기
- 서버가 요청에 대한 결과를 만들어 응답

### 3.3. stateful, stateless
stateful 
- 중간에 다른 서버로 바뀌면 안된다.

stateless
- http 는 stateless 하다.
- 중간에 다른 서버로 바뀌어도 된다.
- 스케일 아웃이 용이하다.

하지만 로그인과 같이 상태를 유지해야하는 경우에 브라우저 쿠키와 서버 세션을 사용해 상태를 유지할 수 있다.  
어쩔 수 없이 한계가 있다.  
꼭 필요한 경우에만 최소한으로 사용해야한다.  

### 3.4. 비 연결성 (connectionless)
장점
- 연결을 유지하지 않으면 서버의 자원을 최소한으로 유지할 수 있다.
- HTTP는 기본이 연결을 유지하지 않는 모델이다.
- 일반적으로 초단위 이하의 빠른 속도로 응답한다.
- 1시간동안 수천명이 서비스를 사용해도 실제 서버에 동시에 처리하는 요청은 수십개이하로 매우 적다.
- 서버 자원을 매우 효율적으로 사용할 수 있다.

한계와 극복
- TCP/IP 연결을 새로 맺어야한다. (3 way handshake)
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js, css, img 등 수많은 자원이 함께 다운로드된다.
- 지금은 HTTP 지속연결(Persistent Connections) 로 문제 해결한다.
- HTTP/2, HTTP/3 에서 더 많은 최적화가 되었다.

지속연결
- 리소스를 모두 다운받을때까지 일정시간 연결해 연결에 필요한 리소스를 줄인다.
- HTTP/3 에서는 UDP로 연결도 더 개선했다.

### 3.5. HTTP 메시지
![httpMessage.png](img/httpMessage.png)  
메시지 구조는 시작라인, 헤더, 공백라인, 바디로 구성되어 있다.


![reqResMessage.png](img/reqResMessage.png)  
요청 메시지와 응답 메시지는 위와 같고, 요청 메시지도 body를 가질 수 있다.  

요청 메시지  
![reqMessage.png](img/reqMessage.png)  
- 시작라인 : GET, POST 등과 같은 메서드, 절대경로와 쿼리, http 버전이 들어간다.
- 헤더 : 호스트가 들어가는데 호스트와 콜론은 붙인다.

응답 메시지  
![resMessage.png](img/resMessage.png)  
- 시작 라인 : http 버전, http 상태코드가 들어간다.
- 헤더 : http 전송에 필요한 모든 부가정보(메시지 바디 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등등)
- 표준헤더가 너무 많음
- 바디 : 실제 전송할 데이터(문서, 영상, 이미지, json 등등)



